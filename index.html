<!DOCTYPE html>
<html lang="en">

<head>

    
    <title>ЭЮЯ</title>
    
    
</head>
<style>


.bg_text::after {
  content: "";
}


.canvas_container .bg_text::after {
  position: absolute;

}


button, input[type="button"], input[type="submit"] { 
   box-shadow:inset 0px 1px 0px 0px #fbafe3;
	background:linear-gradient(to bottom, #ff5bb0 5%, #ef027d 100%);
	background-color:#ff5bb0;
	border-radius:6px;
	border:1px solid #ee1eb5;
	display:inline-block;
	cursor:pointer;
	color:#ffffff;
	font-family:Arial;
	font-size:25px;
	font-weight:bold;
	padding:6px 24px;
	text-decoration:none;
	text-shadow:0px 1px 0px #c70067;
} 

.canvas_container {
	display: inline-block;
	background-color: #E5E5E5;
}

.canvas_container canvas {
	height: 10em;
	width: 100%;
	z-index: 1;
	position: relative;
}

</style>
<body>

<center>
 <br> <br>
 <a href="index.html"><img src="logo.gif" alt="лого"></a>
 <h3>Стандарт печатных аудиотэгов от <a href="https://ъыь.рф">3znaka</a></h3>
 <br>
  <br>
 <img src="template.gif" alt="образец"> <br> <br>
<h1>1. Обрежь и выпрями тэг</h1>
<h3>Это можно сделать с помощью программы вроде Doc Scanner</h3>
 <img src="pic1.gif" alt="ШАГ 1">




   <canvas width="1" height="1" id="imgRenderingCanvasLeft" hidden></canvas>
   
   
   <div id="audioContainer">
            <div id="audioDropHandler">
                <div class="title_text">
                    
                    <h1>2. Загрузи полученное изображение и укажи ниже число, приложенное к тэгу</h1>
					
					<h3>После этого нажми на "Скачать WAV"</h3>
					
					
					
				
                    <input type="file" hidden id="pngFileInput"><input id="imageset" type="file" onchange="readFileToScale(this.files);">
					<input type="text" id="scaleh" value="110">
                </div><br><br>
                <div class="canvas_container">
                    <div class="bg_text"></div>
                    <canvas width="1" height="1" id="pngDisplay"></canvas>
                </div><br>
                <button onclick="scale();">Скачать WAV</button>
            </div>
        </div>
    </div>

    

<script>


const canvasName = '#pngDisplay';
const canvasScale = document.querySelector(canvasName);
const ctxScale = canvasScale.getContext('2d');

let img;
function readFileToScale(files) 
{
	var fileReader = new FileReader();
	fileReader.readAsDataURL(files[0]);
	fileReader.onload = function(imgBlob) 
	{
		img = new Image();
		let blobRes = imgBlob.target.result
		img.src = blobRes;
	}
}

function scale() 
{
	//ctxScale.imageSmoothingEnabled = smooth.checked;
	let height = scaleh.value;
	canvasScale.width = WIDTH_SIZE
	canvasScale.height = height;
	ctxScale.drawImage(img,0,0,img.width,img.height,0,0,WIDTH_SIZE,height);
	
	
	img2audio(canvasScale.toDataURL());
	//canvasScale.toBlob(function (blob) {img2audio(blob)});
}

</script>



<h1>3. Загрузи WAV для зацикленного воспроизведения</h1>
<h3>Будет играть до тех пор, пока не перезагрузишь страницу</h3>
<input  id="audioFileChooser" type="file" onchange="readFile(this.files);">


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

<h1>Создать свою картинку из звука:</h1>
<div class="grid_container">
        <div id="imageContainer">
            <div id="imgDropHandler">
                
                  



                    <input type="file" id="wavFileInput"><br>
               
                <div class="canvas_container">
                    <div class="bg_text"></div>
                    <canvas width="1" height="1" id="audioDisplay"></canvas>
                </div><br><br>
                <button onclick="downloadChannel('left', 'channel', leftChannelCanvas)">Скачать PNG</button>
				<br><br><button onclick="downloadScaled();" style="font-size: 12px;">Получить огромную квадратную картинку с разрешением 10000x10000</button><canvas hidden="true" id="scaledummy" width="10000" height="10000"></canvas>
            </div>

        </div>





   
    

    

        
    </div>
	<br><br><br><br>
	</center>
</body>
</html> 

<script>
// супер скейлер скрипт
const canvasMain = document.querySelector('#audioDisplay')
const ctxMain = canvasMain.getContext('2d');

const canvasDummy = document.querySelector('#scaledummy');
const ctxDummy = canvasDummy.getContext('2d');

let width;
let height;

function downloadScaled()
{
	ctxDummy.drawImage(canvasMain, 0, 0)
	link.download = "super_upscaled.png";
    canvasDummy.toBlob(function (blob) {
		link.href = URL.createObjectURL(blob);
		link.click();
    }, "image/png");
}
</script>




<script>
function stopper(file) {
document.addEventListener('play', function(e){
    var audios = document.getElementsByTagName('audio');
    for(var i = 0, len = audios.length; i < len;i++){
        if(audios[i] != e.target){
            audios[i].pause();
        }
    }
}, true);
}
</script>





<script>

	function readFile(files) {
		var fileReader = new FileReader();
			fileReader.readAsArrayBuffer(files[0]);
			fileReader.onload = function(e) {
				playAudioFile(e.target.result);
				console.log(("Filename: '" + files[0].name + "'"), ( "(" + ((Math.floor(files[0].size/1024/1024*100))/100) + " MB)" ));
			}
	}
	function playAudioFile(file) {
		var context = new window.AudioContext();
			context.decodeAudioData(file, function(buffer) {
				var source = context.createBufferSource();
					source.buffer = buffer;
					source.loop = true;
					source.connect(context.destination);
					source.start(0); 
			});
	}
	
</script>






    <div id="loading">
       
    </div>
    <!-- Displays if the user is using Safari :( -->
    <div id="notchrome">
       
    </div>







    <script>


        // if (!window.chrome && !(navigator.userAgent.indexOf("Firefox") > 0)) {
        //     notchrome.style.display = "block";
        // }
        audioContainer.ondragover = audioContainer.ondragenter = function (evt) {
            evt.preventDefault();
            audioContainer.style.backgroundColor = "var(--accent)";
        }
        audioContainer.ondragleave = function (evt) {
            evt.preventDefault();
            audioContainer.style.backgroundColor = "var(--bg-accent)";
        }

        imgDropHandler.ondragover = imgDropHandler.ondragenter = function (evt) {
            evt.preventDefault();
            imageContainer.style.backgroundColor = "var(--accent)";
        };
        imgDropHandler.ondragleave = function (evt) {
            evt.preventDefault();
            imageContainer.style.backgroundColor = "var(--bg-accent)";
        }
        // Handles the input file element
        class hackedFileThing {
            constructor() {
                this.dataTransfer;
            }
            preventDefault() {
                console.log("File chosen; not dropped. No need to prevent default");
            };
        }
        function handleFiles() {
            var fileList = new hackedFileThing;
            fileList.dataTransfer = this;
            console.log(fileList.dataTransfer);
            fileInput(fileList);
        }


		function checkAllowPicExt(name) 
		{
			for (ext of [".png", ".jpg", ".jfif", ".jpeg"]) // вот тут добвляй разрешенные разрешения
			{
				if (name.toLowerCase().includes(ext)) 
					return true;
			}
			return false;
		}

        // Handles the drop zone
        imgDropHandler.ondrop = audioContainer.ondrop = fileInput = function (evt) {
            //restore colors
            audioContainer.style.backgroundColor = "var(--bg-accent)";
            imageContainer.style.backgroundColor = "var(--bg-accent)";
            loading.style.opacity = "1";
            evt.preventDefault();

            let file = evt.dataTransfer.files[0];
            let reader = new FileReader();
            if (evt.dataTransfer.files.length > 0) {
                if (checkAllowPicExt(file.name)) {
                    reader.readAsDataURL(file);
                    reader.onload = function (e2) {
                        // Start PNG Process
                        img2audio(e2.target.result);
                    }
                } else if (file.name.includes(".wav")) {
                    reader.readAsArrayBuffer(file);
                    reader.onload = function (e2) {
                        // Start WAV Process
                        audio2img(e2.target.result);
                    }
                } else {
                    console.error("FILE FORMAT INVALID");
                    loading.style.opacity = "0";
                }
            } else {
                console.error("no files were dragged in. did you try to drag a link in?");
                loading.style.opacity = "0";
            }

        };

        const wavInput = document.getElementById("wavFileInput");
        wavInput.addEventListener("change", handleFiles, false);

        const pngInput = document.getElementById("pngFileInput");
        pngInput.addEventListener("change", handleFiles, false);

        function clamp(num, min, max) {
            return num <= min ? min : num >= max ? max : num;
        }
        let leftChannelCanvas = document.getElementById("imgRenderingCanvasLeft");
        var leftCtx = leftChannelCanvas.getContext("2d");

        var audioCanvas = document.getElementById("audioDisplay");
        var ctx = audioCanvas.getContext("2d");


        var pngCanvas = document.getElementById("pngDisplay");
        var pngContext = pngCanvas.getContext("2d");

        const SAMPLE_RATE = 10000;
        const BITRATE = 16;
        const N_CHANNELS = 1;
        const WAV_HEADER_SIZE = 44; // 44 bytes
		
        const audioCtx = new AudioContext({
            sampleRate: SAMPLE_RATE,
        });

        let buffer = null;
        let leftChannelAudio = new Array();


		const WIDTH_SIZE = 500

        const audio2img = (undecodedAudio) => {
            audioCtx.decodeAudioData(undecodedAudio, function (data) {
                // success
                buffer = data;
                let leftChannelPixels = new Array();
                var channelSelector = document.getElementsByName('channel');
                let selectedChannel = 0;
                for (i = 0; i < channelSelector.length; i++) {
                    if (channelSelector[i].checked) {
                        selectedChannel = i;
                    }
                }
                console.log(selectedChannel);
                console.log("Number Of Channels: " + buffer.numberOfChannels);
                if (selectedChannel > buffer.numberOfChannels - 1) {
                    selectedChannel = 0;
                    console.error("this audio file does not have a right channel. defaulting to left");
                }
                let bufL = buffer.getChannelData(selectedChannel);
                // let buf = (buffer.getChannelData(0) + buffer.getChannelData(1))/ 2; 
                for (let i = 0; i < buffer.length; i++) {
                    leftChannelPixels.push(((clamp(bufL[i], -1, 1) + 1) * 0.5) * 768); // 
                    leftChannelAudio.push(bufL[i]);
                }
                // console.log(stride.value);
                buildImage(leftChannelPixels, WIDTH_SIZE, ctx);
                buildImage(leftChannelPixels, WIDTH_SIZE, leftCtx);
                loading.style.opacity = "0";
            }, function () {
                // error
                console.error("COULDN'T CONVERT AUDIO TO IMAGE. CORRECT FORMAT?");
            });
        }

        let link = document.createElement("a");
        function buildImage(audioArray, stride, context) {
            let imgHeight = audioArray.length / stride;
            let imageData = context.createImageData(stride, imgHeight);
            let index = 0;
            for (let y = 0; y < imgHeight; y++) {
                for (let x = 0; x < stride; x++) {
                    imageData.data[4 * stride * y + 4 * x + 0] = clamp(audioArray[index], 0, 255);
                    imageData.data[4 * stride * y + 4 * x + 1] = clamp(audioArray[index] - 256, 0, 255);
                    imageData.data[4 * stride * y + 4 * x + 2] = clamp(audioArray[index] - 512, 0, 255);
                    imageData.data[4 * stride * y + 4 * x + 3] = 255
                    index++;
                }
            }
            // resize canvas
            // the main canvas should just be a display
            context.canvas.width = stride;
            context.canvas.height = imgHeight;
            context.putImageData(imageData, 0, 0);
        }
        function downloadChannel(filename, channel, currentCanvas) {
            link.download = filename + "_" + channel + ".png";
            currentCanvas.toBlob(function (blob) {
                link.href = URL.createObjectURL(blob);
                link.click();
            }, "image/png");
        }


        function build_wav_header(buf, audio_length) {
            // RIFF

            return buf;
        }

        function write_wav_file(samples) {
            let buffer = new ArrayBuffer(WAV_HEADER_SIZE + samples.length * 2);
            let data = new DataView(buffer);

            data.setUint8(0, 'R'.charCodeAt(0));
            data.setUint8(1, 'I'.charCodeAt(0));
            data.setUint8(2, 'F'.charCodeAt(0));
            data.setUint8(3, 'F'.charCodeAt(0));
            data.setUint32(4, 36 + samples.length * N_CHANNELS, true);
            // WAV
            data.setUint8(8, 'W'.charCodeAt(0));
            data.setUint8(9, 'A'.charCodeAt(0));
            data.setUint8(10, 'V'.charCodeAt(0));
            data.setUint8(11, 'E'.charCodeAt(0));
            // fmt
            data.setUint8(12, 'f'.charCodeAt(0));
            data.setUint8(13, 'm'.charCodeAt(0));
            data.setUint8(14, 't'.charCodeAt(0));
            data.setUint8(15, ' '.charCodeAt(0));
            data.setUint32(16, 16, true);
            data.setUint16(20, 1, true); // Audio format 1 = PCM
            data.setUint16(22, N_CHANNELS, true);
            data.setUint32(24, SAMPLE_RATE, true);
            data.setUint32(28, SAMPLE_RATE * N_CHANNELS * BITRATE / 8, true);
            data.setUint16(32, N_CHANNELS * BITRATE / 8, true);
            data.setUint16(34, BITRATE, true);
            data.setUint8(36, 'd'.charCodeAt(0));
            data.setUint8(37, 'a'.charCodeAt(0));
            data.setUint8(38, 't'.charCodeAt(0));
            data.setUint8(39, 'a'.charCodeAt(0));
            data.setUint32(40, samples.length * 2 * N_CHANNELS, true);

            console.log("samples length: ", samples.length);

            for (let i = 0; i < samples.length; i++) {
                let sample = samples[i];

                data.setInt16(WAV_HEADER_SIZE + i * 2, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
            }
            return data;
        }

        // AUDIO
        let currentAudioBlob = null;
        function exportWAV(type, floatAudioBuffer, audioLength) {
            var channel = 0;
            var i = 0, offset = 0, newbuffers = [];

            newbuffers[channel] = new Float32Array(audioLength);
            newbuffers[channel].set(floatAudioBuffer);

            var interleaved = newbuffers[0];

            var dataview = write_wav_file(floatAudioBuffer);
            var audioBlob = new Blob([dataview], { type: type });
            currentAudioBlob = audioBlob;
            this.postMessage(audioBlob);
		
        }

        function downloadAudio() {
            link.download = "audio.wav";

            link.href = URL.createObjectURL(currentAudioBlob);
            link.click();
        }
        const img2audio = (imgBlob) => {
            console.log(imgBlob);
			var img = new Image();
            console.log(imgBlob);
			img.src = imgBlob;
            img.onload = function () {
                console.log(img);
                pngContext.canvas.width = img.width;
                pngContext.canvas.height = img.height;
                pngContext.drawImage(img, 0, 0);
                let imageData = pngContext.getImageData(0, 0, img.width, img.height).data;
                let newImageData = Array();
                for (let i = 0; i < imageData.length; i += 4) {
                    newImageData.push((((imageData[i] + imageData[i + 1] + imageData[i + 2]) / 768) - 0.5) * 2);
                }
                loading.style.opacity = "0";
                exportWAV("audio/wav", newImageData, newImageData.length);
				downloadAudio();
            };
        }





    </script>

<!--
<script>
const MAX_WIDTH = 3000;
const QUALITY = 1;

const readPhoto = async (photo) => {
  const canvas = document.createElement("canvas");
  const img = document.createElement("img");

  // create img element from File object
  img.src = await new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target.result);
    reader.readAsDataURL(photo);
  });

  await new Promise((resolve) => {
    img.onload = resolve;
  });

  // draw image in canvas element
  canvas.width = img.width;
  canvas.height = img.height;
  canvas.getContext("2d").drawImage(img, 0, 0, canvas.width, canvas.height);

  return canvas;
};


//var numba = document.getElementById('dd').value;
  


var scaleCanvas = (canvas, scale) => {
  
  var scaledCanvas = document.createElement("canvas");
  scaledCanvas.height = 100;
  scaledCanvas.width = 500;
   

  scaledCanvas
    .getContext("2d")
    .drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);

  return scaledCanvas;
};

const optimizePhoto = async (photo) => {
  let canvas = await readPhoto(photo);

  
  while (canvas.width >= 2 * MAX_WIDTH) {
    canvas = scaleCanvas(canvas, 0.5);
  }

  if (canvas.width > MAX_WIDTH) {
    canvas = scaleCanvas(canvas, MAX_WIDTH / canvas.width);
  }

  return new Promise((resolve) => {
    canvas.toBlob(resolve, "image/jpeg", QUALITY);
  });
};

const input = document.getElementById("fileField");

async function processReduce(photo) {
  const resizedPhoto = await optimizePhoto(photo);
  console.log(resizedPhoto);
  
  let reader = new FileReader();
  reader.readAsDataURL(resizedPhoto); // converts the blob to base64 and calls onload

  reader.onload = function () {
    document.getElementById("img1").src = reader.result; // data url
  };
}

input.addEventListener("change", function (e) {
  processReduce(e.target.files[0]);
});
 -->

</script>








</body>

</html>